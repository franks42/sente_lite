<!DOCTYPE html>
<html>
<head>
  <title>FQN Registry Tests - Scittle</title>
  <script src="https://cdn.jsdelivr.net/npm/scittle@0.6.19/dist/scittle.js"></script>
  <style>
    body { font-family: monospace; padding: 20px; }
    .pass { color: green; }
    .fail { color: red; }
    pre { background: #f4f4f4; padding: 10px; }
  </style>
</head>
<body>
  <h1>FQN Registry Tests (Scittle/Browser)</h1>
  <pre id="output"></pre>

  <!-- Inline registry code to avoid CORS issues -->
  <script type="application/x-scittle">
(ns sente-lite.registry
  "FQN-based registry for managing named resources across processes.")

;; Configuration
(defonce ^:private reg-root (atom "sente-lite.registry"))

(defn get-reg-root [] @reg-root)

(defn set-reg-root! [root] (reset! reg-root root))

;; Internal Helpers
(def ^:private valid-name-pattern #"[a-z][a-z0-9]*(\.[a-z][a-z0-9]*)*/[a-z][a-z0-9-]*")

(defn- valid-name? [name]
  (and (string? name) (re-matches valid-name-pattern name)))

(defn- validate-name! [name]
  (when-not (valid-name? name)
    (throw (ex-info "Invalid registry name format. Expected: category/name (e.g., state/user-prefs)"
                    {:name name :pattern (str valid-name-pattern)}))))

(defn- absolute-fqn [name]
  (let [slash-idx (.indexOf name "/")
        category (subs name 0 slash-idx)
        var-name (subs name (inc slash-idx))]
    (str @reg-root "." category "/" var-name)))

(defn- name->symbols [name]
  (let [fqn (absolute-fqn name)
        sym (symbol fqn)]
    [(symbol (namespace sym))
     (symbol (clojure.core/name sym))]))

;; Internal State Tracking
(defonce ^:private registered-names (atom #{}))

;; Registration
(defn register! [name initial-value]
  (validate-name! name)
  (let [syms (name->symbols name)
        ns-sym (first syms)
        name-sym (second syms)]
    (create-ns ns-sym)
    (let [a (atom initial-value)]
      (intern ns-sym name-sym a)
      (swap! registered-names conj name)
      a)))

(defn ensure! [name]
  (validate-name! name)
  (let [syms (name->symbols name)
        ns-sym (first syms)
        name-sym (second syms)
        _ (create-ns ns-sym)
        existing (find-var (symbol (absolute-fqn name)))]
    (if existing
      @existing
      (let [a (atom nil)]
        (intern ns-sym name-sym a)
        (swap! registered-names conj name)
        a))))

;; Read
(defn get-ref [name]
  (validate-name! name)
  (when-let [v (find-var (symbol (absolute-fqn name)))]
    @v))

(defn get-value [name]
  (when-let [ref (get-ref name)]
    @ref))

;; Write
(defn set-value! [name new-value]
  (if-let [ref (get-ref name)]
    (reset! ref new-value)
    (throw (ex-info "Registry name not found" {:name name}))))

(defn swap-value! [name f & args]
  (if-let [ref (get-ref name)]
    (apply swap! ref f args)
    (throw (ex-info "Registry name not found" {:name name}))))

;; Write (with reference)
(defn set-ref! [ref new-value] (reset! ref new-value))
(defn swap-ref! [ref f & args] (apply swap! ref f args))

;; Discovery
(defn registered? [name]
  (validate-name! name)
  (contains? @registered-names name))

(defn list-registered [] @registered-names)

(defn list-registered-prefix [prefix]
  (into #{} (filter #(.startsWith % prefix) @registered-names)))

;; Cleanup
(defn unregister! [name]
  (validate-name! name)
  (when-let [ref (get-ref name)]
    (reset! ref nil)
    (swap! registered-names disj name)
    true))

(defn unregister-prefix! [prefix]
  (let [names-to-remove (list-registered-prefix prefix)]
    (doseq [name names-to-remove]
      (when-let [ref (get-ref name)]
        (reset! ref nil)))
    (swap! registered-names #(reduce disj % names-to-remove))
    (count names-to-remove)))

;; Watch
(defn watch! [name key callback]
  (if-let [ref (get-ref name)]
    (add-watch ref key (fn [k _ old new] (callback k name old new)))
    (throw (ex-info "Registry name not found" {:name name}))))

(defn unwatch! [name key]
  (if-let [ref (get-ref name)]
    (remove-watch ref key)
    (throw (ex-info "Registry name not found" {:name name}))))
  </script>

  <script type="application/x-scittle">
(ns sente-lite.registry-test
  (:require [sente-lite.registry :as reg]))

(def output-el (js/document.getElementById "output"))
(def tests-passed (atom 0))
(def tests-failed (atom 0))
(def results (atom []))

(defn log [s]
  (swap! results conj s))

(defn test-case [name test-fn]
  (log (str "  " name "... "))
  (try
    (if (test-fn)
      (do (log "✓\n")
          (swap! tests-passed inc))
      (do (log "✗ FAILED\n")
          (swap! tests-failed inc)))
    (catch js/Error e
      (log (str "✗ ERROR: " (.-message e) "\n"))
      (swap! tests-failed inc))))

(log "=== FQN Registry Tests (Scittle) ===\n\n")

;; Test 1: get-reg-root
(test-case "get-reg-root returns default"
  #(= "sente-lite.registry" (reg/get-reg-root)))

;; Test 2: set-reg-root!
(test-case "set-reg-root! changes root"
  #(do (reg/set-reg-root! "test.registry")
       (let [result (= "test.registry" (reg/get-reg-root))]
         (reg/set-reg-root! "sente-lite.registry")
         result)))

;; Test 3: register! and get-value
(test-case "register! creates resource, get-value reads it"
  #(do (reg/register! "state/user" {:name "Alice"})
       (= {:name "Alice"} (reg/get-value "state/user"))))

;; Test 4: set-value!
(test-case "set-value! updates value"
  #(do (reg/set-value! "state/user" {:name "Bob"})
       (= {:name "Bob"} (reg/get-value "state/user"))))

;; Test 5: swap-value!
(test-case "swap-value! applies function"
  #(do (reg/register! "state/counter" 0)
       (reg/swap-value! "state/counter" inc)
       (reg/swap-value! "state/counter" inc)
       (= 2 (reg/get-value "state/counter"))))

;; Test 6: swap-value! with args
(test-case "swap-value! with extra args"
  #(do (reg/swap-value! "state/user" assoc :role :admin)
       (= :admin (:role (reg/get-value "state/user")))))

;; Test 7: ensure! idempotent
(test-case "ensure! is idempotent"
  #(let [ref1 (reg/ensure! "state/temp")
         ref2 (reg/ensure! "state/temp")]
       (identical? ref1 ref2)))

;; Test 8: get-ref returns atom
(test-case "get-ref returns the atom"
  #(let [ref (reg/get-ref "state/counter")]
       (and (some? ref)
            (= 2 @ref))))

;; Test 9: set-ref! and swap-ref!
(test-case "set-ref!/swap-ref! work with cached ref"
  #(let [ref (reg/get-ref "state/counter")]
       (reg/set-ref! ref 100)
       (reg/swap-ref! ref + 5)
       (= 105 @ref)))

;; Test 10: registered?
(test-case "registered? returns true for existing"
  #(reg/registered? "state/user"))

(test-case "registered? returns false for non-existing"
  #(not (reg/registered? "state/nonexistent")))

;; Test 11: list-registered
(test-case "list-registered shows all names"
  #(let [names (reg/list-registered)]
       (and (contains? names "state/user")
            (contains? names "state/counter"))))

;; Test 12: list-registered-prefix
(test-case "list-registered-prefix filters by prefix"
  #(do (reg/register! "sync/shared" {})
       (let [sync-names (reg/list-registered-prefix "sync/")]
         (and (contains? sync-names "sync/shared")
              (not (contains? sync-names "state/user"))))))

;; Test 13: unregister!
(test-case "unregister! removes from tracking"
  #(do (reg/register! "state/todelete" {:temp true})
       (reg/unregister! "state/todelete")
       (and (not (reg/registered? "state/todelete"))
            (nil? (reg/get-value "state/todelete")))))

;; Test 14: unregister-prefix!
(test-case "unregister-prefix! removes multiple"
  #(do (reg/register! "temp/a" 1)
       (reg/register! "temp/b" 2)
       (reg/register! "temp/c" 3)
       (let [cnt (reg/unregister-prefix! "temp/")]
         (and (= 3 cnt)
              (empty? (reg/list-registered-prefix "temp/"))))))

;; Test 15: watch! and unwatch!
(test-case "watch! receives changes"
  #(let [changes (atom [])
         _ (reg/register! "watch/test" 0)
         _ (reg/watch! "watch/test" :test-watch
             (fn [k n old new]
               (swap! changes conj {:old old :new new})))
         _ (reg/set-value! "watch/test" 1)
         _ (reg/set-value! "watch/test" 2)
         _ (reg/unwatch! "watch/test" :test-watch)]
       (and (= 2 (count @changes))
            (= {:old 0 :new 1} (first @changes))
            (= {:old 1 :new 2} (second @changes)))))

;; Test 16: Invalid name validation
(test-case "Invalid name throws"
  #(try
     (reg/register! "Invalid Name!" {})
     false
     (catch js/Error e
       (not (nil? (re-find #"Invalid registry name" (.-message e)))))))

;; Test 17: Name without category throws
(test-case "Name without category throws"
  #(try
     (reg/register! "nocat" {})
     false
     (catch js/Error e
       true)))

;; Test 18: get-value on non-existent returns nil
(test-case "get-value on non-existent returns nil"
  #(nil? (reg/get-value "state/doesnotexist")))

;; Cleanup
(reg/unregister! "state/user")
(reg/unregister! "state/counter")
(reg/unregister! "state/temp")
(reg/unregister! "sync/shared")
(reg/unregister! "watch/test")

;; Summary
(log (str "\n=== Results: " @tests-passed " passed, " @tests-failed " failed ===\n"))

;; Render output
(set! (.-textContent output-el) (apply str @results))

;; Set window.testResults for Playwright
(aset js/window "testResults" #js {:passed @tests-passed :failed @tests-failed})
(js/console.log "Tests complete:" @tests-passed "passed," @tests-failed "failed")
  </script>
</body>
</html>
