<!DOCTYPE html>
<html>
<head>
  <title>Component System Tests (Scittle)</title>
  <script src="https://cdn.jsdelivr.net/npm/scittle@0.7.30/dist/scittle.js"></script>
</head>
<body>
<h1>Component System Tests (Scittle)</h1>
<pre id="results" style="font-family: monospace; white-space: pre-wrap;"></pre>

<!-- Component system (inline for CORS) -->
<script type="application/x-scittle">
(ns sente-lite.component
  "Multimethod-based component system for sente-lite.")

;;; Lifecycle Multimethods
(defmulti start! :component/type)
(defmulti stop! :component/type)

;;; Introspection Multimethods
(defmulti status :component/type)
(defmulti health :component/type)
(defmulti stats :component/type)

;;; Default Implementations
(defmethod start! :default [c]
  (throw (ex-info "No start! implementation for component type"
                  {:component/type (:component/type c)
                   :component c})))

(defmethod stop! :default [_] :ok)

(defmethod status :default [comp]
  (let [state (get comp :state)]
    (if state
      (get @state :status :unknown)
      :unknown)))

(defmethod health :default [c]
  (let [s (status c)]
    {:healthy? (= :running s)
     :status s
     :type (:component/type c)}))

(defmethod stats :default [comp]
  (let [state (get comp :state)]
    (if state
      (let [started-at (get @state :started-at)]
        (if started-at
          {:started-at started-at
           :uptime-ms (- (.now js/Date) started-at)}
          {}))
      {})))

;;; Component Factory
(defn make-component [component-type config]
  {:component/type component-type
   :config config
   :state (atom {:status :stopped
                 :started-at nil
                 :error nil})})

(defn make-component-with-state [component-type config initial-state]
  {:component/type component-type
   :config config
   :state (atom (merge {:status :stopped
                        :started-at nil
                        :error nil}
                       initial-state))})

;;; Convenience Predicates
(defn running? [c] (= :running (status c)))
(defn stopped? [c] (= :stopped (status c)))
(defn starting? [c] (= :starting (status c)))
(defn stopping? [c] (= :stopping (status c)))
(defn error? [c] (= :error (status c)))
(defn healthy? [c] (:healthy? (health c)))

;;; State Transition Helpers
(defn set-status! [comp new-status]
  (let [state (get comp :state)]
    (swap! state assoc :status new-status)
    new-status))

(defn set-started! [comp]
  (let [state (get comp :state)]
    (swap! state assoc
           :status :running
           :started-at (.now js/Date)
           :error nil))
  :ok)

(defn set-stopped! [comp]
  (let [state (get comp :state)]
    (swap! state assoc
           :status :stopped
           :started-at nil))
  :ok)

(defn set-error! [comp error]
  (let [state (get comp :state)]
    (swap! state assoc
           :status :error
           :error error))
  :error)

;;; System Management
(defn- try-start-one! [c]
  (try
    (start! c)
    {:ok c}
    (catch :default e
      {:error e :component c})))

(defn- rollback-started! [started]
  (doseq [s (reverse started)]
    (try (stop! s) (catch :default _))))

(defn start-all! [components]
  (let [result (reduce
                (fn [started c]
                  (let [r (try-start-one! c)]
                    (if (:ok r)
                      (conj started c)
                      (reduced {:failed c :started started :error (:error r)}))))
                []
                components)]
    (if (vector? result)
      :ok
      (do
        (rollback-started! (:started result))
        (throw (ex-info "Failed to start components"
                        {:failed-component (:component/type (:failed result))
                         :started-components (mapv :component/type (:started result))
                         :error (:error result)}))))))

(defn stop-all! [components]
  (let [errors (atom [])]
    (doseq [c (reverse components)]
      (try
        (stop! c)
        (catch :default e
          (swap! errors conj {:component (:component/type c) :error e}))))
    (if (empty? @errors)
      :ok
      {:errors @errors})))

(defn status-all [components]
  (into {}
        (map (fn [c] [(:component/type c) (status c)]))
        components))

(defn health-all [components]
  (let [healths (map (fn [c] [(:component/type c) (health c)]) components)]
    {:healthy? (every? :healthy? (map second healths))
     :components (into {} healths)}))
</script>

<!-- Test code - SEPARATE script block with different namespace -->
<script type="application/x-scittle">
(ns component-test
  (:require [sente-lite.component :as c]))

(def results (atom []))
(def tests-passed (atom 0))
(def tests-failed (atom 0))

(defn test-result [name passed? & [msg]]
  (if passed?
    (do (swap! tests-passed inc)
        (swap! results conj (str "  [PASS] " name)))
    (do (swap! tests-failed inc)
        (swap! results conj (str "  [FAIL] " name (if msg (str " - " msg) ""))))))

(defn log [& args]
  (swap! results conj (apply str args)))

(log "=== Component System Tests (Scittle) ===\n")

;;; Test 1: make-component creates valid structure
(log "Test 1: make-component")
(let [comp (c/make-component :test/basic {:port 8080})]
  (test-result "has :component/type" (= :test/basic (:component/type comp)))
  (test-result "has :config" (= {:port 8080} (:config comp)))
  (test-result "has :state atom" (some? (:state comp)))
  (test-result "initial status is :stopped" (= :stopped (:status @(:state comp)))))

;;; Test 2: Default implementations
(log "\nTest 2: Default implementations")
(let [comp (c/make-component :test/defaults {})]
  (test-result "status returns :stopped" (= :stopped (c/status comp)))
  (test-result "stopped? returns true" (c/stopped? comp))
  (test-result "running? returns false" (not (c/running? comp)))
  (test-result "health returns unhealthy" (not (:healthy? (c/health comp))))
  (test-result "stop! default returns :ok" (= :ok (c/stop! comp)))
  (test-result "stats returns empty map" (= {} (c/stats comp))))

;;; Test 3: start! throws for unimplemented type
(log "\nTest 3: start! throws for unimplemented type")
(let [comp (c/make-component :test/no-impl {})]
  (try
    (c/start! comp)
    (test-result "throws on missing impl" false "did not throw")
    (catch js/Error e
      (test-result "throws on missing impl" true))))

;;; Test 4: Custom component implementation
(log "\nTest 4: Custom component implementation")

;; Define a test component
(defmethod c/start! :test/custom
  [comp]
  (let [config (get comp :config)]
    (when (c/stopped? comp)
      (c/set-started! comp)
      (log "    -> Custom component started with " config)))
  :ok)

(defmethod c/stop! :test/custom
  [comp]
  (when (c/running? comp)
    (c/set-stopped! comp)
    (log "    -> Custom component stopped"))
  :ok)

(defmethod c/stats :test/custom
  [comp]
  (let [state (get comp :state)
        config (get comp :config)
        base-stats (c/stats {:state state})]
    (merge base-stats
           {:custom-metric 42
            :config-keys (keys config)})))

(let [comp (c/make-component :test/custom {:port 3000 :host "localhost"})]
  (test-result "starts as stopped" (c/stopped? comp))

  (c/start! comp)
  (test-result "running after start!" (c/running? comp))
  (test-result "healthy after start!" (c/healthy? comp))
  (test-result "has started-at" (some? (:started-at @(:state comp))))

  (let [stats (c/stats comp)]
    (test-result "custom stats includes metric" (= 42 (:custom-metric stats)))
    (test-result "custom stats includes uptime" (number? (:uptime-ms stats))))

  (c/stop! comp)
  (test-result "stopped after stop!" (c/stopped? comp))
  (test-result "not healthy after stop!" (not (c/healthy? comp))))

;;; Test 5: State transition helpers
(log "\nTest 5: State transition helpers")
(let [comp (c/make-component :test/helpers {})]
  (c/set-status! comp :starting)
  (test-result "set-status! to :starting" (c/starting? comp))

  (c/set-started! comp)
  (test-result "set-started! sets :running" (c/running? comp))
  (test-result "set-started! sets timestamp" (some? (:started-at @(:state comp))))

  (c/set-error! comp {:reason "test error"})
  (test-result "set-error! sets :error" (c/error? comp))
  (test-result "set-error! stores error info" (= {:reason "test error"} (:error @(:state comp))))

  (c/set-stopped! comp)
  (test-result "set-stopped! sets :stopped" (c/stopped? comp)))

;;; Test 6: System management (start-all!, stop-all!)
(log "\nTest 6: System management")

;; Components for system test
(defmethod c/start! :test/sys-a
  [comp]
  (c/set-started! comp)
  (log "    -> sys-a started")
  :ok)

(defmethod c/stop! :test/sys-a
  [comp]
  (c/set-stopped! comp)
  (log "    -> sys-a stopped")
  :ok)

(defmethod c/start! :test/sys-b
  [comp]
  (c/set-started! comp)
  (log "    -> sys-b started")
  :ok)

(defmethod c/stop! :test/sys-b
  [comp]
  (c/set-stopped! comp)
  (log "    -> sys-b stopped")
  :ok)

(let [comp-a (c/make-component :test/sys-a {})
      comp-b (c/make-component :test/sys-b {})
      system [comp-a comp-b]]

  ;; Start all
  (let [result (c/start-all! system)]
    (test-result "start-all! returns :ok" (= :ok result))
    (test-result "all running after start-all!"
                 (every? c/running? system)))

  ;; Status all
  (let [statuses (c/status-all system)]
    (test-result "status-all returns all :running"
                 (= {:test/sys-a :running :test/sys-b :running} statuses)))

  ;; Health all
  (let [health (c/health-all system)]
    (test-result "health-all :healthy? true" (:healthy? health))
    (test-result "health-all has all components"
                 (= 2 (count (:components health)))))

  ;; Stop all
  (let [result (c/stop-all! system)]
    (test-result "stop-all! returns :ok" (= :ok result))
    (test-result "all stopped after stop-all!"
                 (every? c/stopped? system))))

;;; Test 7: start-all! rollback on failure
(log "\nTest 7: start-all! rollback on failure")

(defmethod c/start! :test/fail-start
  [_]
  (throw (js/Error. "Intentional failure")))

(let [comp-a (c/make-component :test/sys-a {})
      comp-fail (c/make-component :test/fail-start {})
      system [comp-a comp-fail]]

  (try
    (c/start-all! system)
    (test-result "throws on failure" false "did not throw")
    (catch js/Error e
      (test-result "throws on failure" true)
      ;; Check rollback happened
      (test-result "rolled back comp-a" (c/stopped? comp-a)))))

;;; Summary
(log "\n=== Results ===")
(log "Passed: " @tests-passed)
(log "Failed: " @tests-failed)
(log "Total:  " (+ @tests-passed @tests-failed))

(if (zero? @tests-failed)
  (log "\nAll tests passed!")
  (log "\nSome tests failed!"))

;; Display results
(set! (.-textContent (js/document.getElementById "results"))
      (clojure.string/join "\n" @results))

;; Log to console for Playwright
(js/console.log "=== SCITTLE COMPONENT TESTS ===")
(doseq [r @results] (js/console.log r))
(js/console.log (str "TESTS_PASSED=" @tests-passed))
(js/console.log (str "TESTS_FAILED=" @tests-failed))
</script>
</body>
</html>
