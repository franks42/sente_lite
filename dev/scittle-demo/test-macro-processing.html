<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Macro Processing Test</title>

  <!-- Load Scittle core -->
  <script src="https://cdn.jsdelivr.net/npm/scittle@0.7.28/dist/scittle.js"
          type="application/javascript"></script>

  <!-- Load Trove -->
  <script src="src/taoensso/trove/utils.cljc" type="application/x-scittle"></script>
  <script src="src/taoensso/trove/console.cljc" type="application/x-scittle"></script>
  <script src="src/taoensso/trove.cljc" type="application/x-scittle"></script>

  <!-- Load our wrapper -->
  <script src="trove-macros.cljs" type="application/x-scittle"></script>

  <style>
    body { font-family: monospace; margin: 20px; }
    h1 { color: #333; }
    .result { background: white; border: 1px solid #ddd; padding: 15px; margin-top: 20px; }
    .test { margin: 10px 0; padding: 10px; border-left: 3px solid #ccc; }
    .pass { border-left-color: green; background: #f0fff0; }
    .fail { border-left-color: red; background: #fff0f0; }
  </style>
</head>
<body>
  <h1>üß™ Macro Processing Test</h1>
  
  <div class="result">
    <h2>Test Results</h2>
    <div id="results"></div>
  </div>

  <script type="application/x-scittle">
    ;; Create test namespace with macro and function
    (ns test.macros)

    ;; Counter to track evaluations
    (def eval-count (atom 0))

    ;; Expensive computation that tracks when it's called
    (defn expensive-computation []
      (swap! eval-count inc)
      (println (str "‚ùå EXPENSIVE COMPUTATION CALLED! Count: " @eval-count))
      "expensive-result")

    ;; MACRO version - should guard evaluation
    (defmacro macro-log [level id data]
      `(do
         (println (str "üîµ MACRO: Executing with level=" ~level " id=" ~id))
         ~data))

    ;; FUNCTION version - always evaluates parameters
    (defn function-log [level id data]
      (println (str "üü¢ FUNCTION: Executing with level=" level " id=" id))
      data)

    (println "‚úÖ Test setup complete!")
  </script>

  <script type="application/x-scittle">
    ;; Test 1: Macro with :refer - does it get real macro processing?
    (println "\n=== Test 1: Macro with :refer ===")
    (require '[test.macros :refer [macro-log]])
    (reset! test.macros/eval-count 0)
    
    (println "Calling: (macro-log :info :test/refer (expensive-computation))")
    (macro-log :info :test/refer (test.macros/expensive-computation))
    
    (println (str "Result: expensive-computation was called " @test.macros/eval-count " time(s)"))
    (if (= @test.macros/eval-count 1)
      (println "‚úÖ Test 1 PASS: Macro processed (expensive-computation called)")
      (println (str "‚ùå Test 1 FAIL: Expected 1 call, got " @test.macros/eval-count)))
  </script>

  <script type="application/x-scittle">
    ;; Test 2: Function with :refer - always evaluates parameters
    (println "\n=== Test 2: Function with :refer ===")
    (require '[test.macros :refer [function-log]])
    (reset! test.macros/eval-count 0)
    
    (println "Calling: (function-log :info :test/refer (expensive-computation))")
    (function-log :info :test/refer (test.macros/expensive-computation))
    
    (println (str "Result: expensive-computation was called " @test.macros/eval-count " time(s)"))
    (if (= @test.macros/eval-count 1)
      (println "‚úÖ Test 2 PASS: Function called (expensive-computation evaluated)")
      (println (str "‚ùå Test 2 FAIL: Expected 1 call, got " @test.macros/eval-count)))
  </script>

  <script type="application/x-scittle">
    ;; Test 3: Check if macro-log is really a macro
    (println "\n=== Test 3: Is macro-log a macro? ===")
    (require '[test.macros :refer [macro-log]])
    
    (let [macro-meta (meta #'test.macros/macro-log)]
      (println (str "macro-log metadata: " macro-meta))
      (if (:macro macro-meta)
        (println "‚úÖ Test 3 PASS: macro-log IS a macro (:macro true)")
        (println "‚ùå Test 3 FAIL: macro-log is NOT a macro")))
  </script>

  <script type="application/x-scittle">
    ;; Test 4: Check if function-log is a function
    (println "\n=== Test 4: Is function-log a function? ===")
    (require '[test.macros :refer [function-log]])
    
    (let [fn-meta (meta #'test.macros/function-log)]
      (println (str "function-log metadata: " fn-meta))
      (if (fn? test.macros/function-log)
        (println "‚úÖ Test 4 PASS: function-log IS a function")
        (println "‚ùå Test 4 FAIL: function-log is NOT a function")))
  </script>

  <script type="application/x-scittle">
    ;; Test 5: Check if our wrapper (trove.macros/log!) is a macro or function
    (println "\n=== Test 5: Is our wrapper a macro or function? ===")
    (require '[trove.macros :refer [log!]])
    
    (let [wrapper-meta (meta #'trove.macros/log!)]
      (println (str "trove.macros/log! metadata: " wrapper-meta))
      (if (:macro wrapper-meta)
        (println "‚úÖ Test 5 PASS: Our wrapper IS a macro")
        (do
          (println "‚ùå Test 5 FAIL: Our wrapper is a FUNCTION (not optimized!)")
          (println "   This means parameters are ALWAYS evaluated"))))
  </script>

  <script type="application/x-scittle">
    ;; Test 6: Check if Trove's log! is a macro
    (println "\n=== Test 6: Is trove/log! a macro? ===")
    (require '[taoensso.trove :as trove])
    
    (let [trove-meta (meta #'trove/log!)]
      (println (str "trove/log! metadata: " trove-meta))
      (if (:macro trove-meta)
        (println "‚úÖ Test 6 PASS: trove/log! IS a macro")
        (println "‚ùå Test 6 FAIL: trove/log! is NOT a macro")))
  </script>

  <script type="application/x-scittle">
    ;; Final Summary
    (println "\n" (apply str (repeat 60 "=")))
    (println "FINAL ANSWER")
    (println (apply str (repeat 60 "=")))
    (println "\nWhen using (require '... :refer [...]):")
    (println "‚úÖ Macros ARE processed as real macros")
    (println "‚úÖ Functions ARE processed as functions")
    (println "‚úÖ :refer imports preserve the type (macro vs function)")
    (println "\nOur wrapper (trove.macros/log!):")
    (println "‚ùå IS a FUNCTION, not a macro")
    (println "‚ùå So parameters are ALWAYS evaluated")
    (println "‚ùå No optimization for expensive computations")
    (println "\nTo get macro optimization in browser, we would need:")
    (println "1. Compiled JS version with SCI runtime (~500KB)")
    (println "2. Or rewrite wrapper as a macro (doesn't work in SCI)")
    (println "3. Or use Trove's direct API (what we're doing)")
  </script>
</body>
</html>
