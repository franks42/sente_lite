<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Macro vs Function Test</title>

  <!-- Load Scittle core -->
  <script src="https://cdn.jsdelivr.net/npm/scittle@0.7.28/dist/scittle.js"
          type="application/javascript"></script>

  <style>
    body { font-family: monospace; margin: 20px; }
    h1 { color: #333; }
    .result { background: white; border: 1px solid #ddd; padding: 15px; margin-top: 20px; }
    .test { margin: 10px 0; padding: 10px; border-left: 3px solid #ccc; }
    .pass { border-left-color: green; background: #f0fff0; }
    .fail { border-left-color: red; background: #fff0f0; }
  </style>
</head>
<body>
  <h1>üß™ Macro vs Function Test</h1>
  
  <div class="result">
    <h2>Test Results</h2>
    <div id="results"></div>
  </div>

  <script type="application/x-scittle">
    ;; Create a test macro and function to compare behavior
    (ns test.macros)

    ;; Counter to track evaluations
    (def eval-count (atom 0))

    ;; Expensive computation that tracks when it's called
    (defn expensive-computation []
      (swap! eval-count inc)
      (println (str "‚ùå Expensive computation called! Count: " @eval-count))
      "expensive-result")

    ;; MACRO version - should guard evaluation
    (defmacro macro-log [level id data]
      (println "üìù MACRO: Expanding macro at compile time")
      `(do
         (println (str "üîµ MACRO: Executing at runtime with level=" ~level " id=" ~id))
         ~data))

    ;; FUNCTION version - always evaluates parameters
    (defn function-log [level id data]
      (println (str "üü¢ FUNCTION: Executing at runtime with level=" level " id=" id))
      data)

    (println "‚úÖ Test setup complete!")
  </script>

  <script type="application/x-scittle">
    ;; Test 1: Direct macro call (inline)
    (println "\n=== Test 1: Direct Macro Call (Inline) ===")
    (reset! test.macros/eval-count 0)
    
    (test.macros/macro-log :info :test/direct (test.macros/expensive-computation))
    
    (if (= @test.macros/eval-count 1)
      (println "‚úÖ Test 1 PASS: Macro expanded, expensive-computation called once")
      (println (str "‚ùå Test 1 FAIL: Expected 1 call, got " @test.macros/eval-count)))
  </script>

  <script type="application/x-scittle">
    ;; Test 2: Function call (inline)
    (println "\n=== Test 2: Direct Function Call (Inline) ===")
    (reset! test.macros/eval-count 0)
    
    (test.macros/function-log :info :test/direct (test.macros/expensive-computation))
    
    (if (= @test.macros/eval-count 1)
      (println "‚úÖ Test 2 PASS: Function called, expensive-computation evaluated once")
      (println (str "‚ùå Test 2 FAIL: Expected 1 call, got " @test.macros/eval-count)))
  </script>

  <script type="application/x-scittle">
    ;; Test 3: Macro with :refer
    (println "\n=== Test 3: Macro with :refer ===")
    (require '[test.macros :refer [macro-log]])
    (reset! test.macros/eval-count 0)
    
    (macro-log :info :test/refer (test.macros/expensive-computation))
    
    (if (= @test.macros/eval-count 1)
      (println "‚úÖ Test 3 PASS: Macro with :refer works, expensive-computation called once")
      (println (str "‚ùå Test 3 FAIL: Expected 1 call, got " @test.macros/eval-count)))
  </script>

  <script type="application/x-scittle">
    ;; Test 4: Function with :refer
    (println "\n=== Test 4: Function with :refer ===")
    (require '[test.macros :refer [function-log]])
    (reset! test.macros/eval-count 0)
    
    (function-log :info :test/refer (test.macros/expensive-computation))
    
    (if (= @test.macros/eval-count 1)
      (println "‚úÖ Test 4 PASS: Function with :refer works, expensive-computation called once")
      (println (str "‚ùå Test 4 FAIL: Expected 1 call, got " @test.macros/eval-count)))
  </script>

  <script type="application/x-scittle">
    ;; Test 5: Check if macro-log is actually a macro
    (println "\n=== Test 5: Check if macro-log is a macro ===")
    (require '[test.macros :refer [macro-log]])
    
    (let [macro-meta (meta #'test.macros/macro-log)]
      (println (str "Macro metadata: " macro-meta))
      (if (:macro macro-meta)
        (println "‚úÖ Test 5 PASS: macro-log is recognized as a macro")
        (println "‚ùå Test 5 FAIL: macro-log is NOT recognized as a macro")))
  </script>

  <script type="application/x-scittle">
    ;; Test 6: Check if function-log is a function
    (println "\n=== Test 6: Check if function-log is a function ===")
    (require '[test.macros :refer [function-log]])
    
    (let [fn-meta (meta #'test.macros/function-log)]
      (println (str "Function metadata: " fn-meta))
      (if (fn? test.macros/function-log)
        (println "‚úÖ Test 6 PASS: function-log is recognized as a function")
        (println "‚ùå Test 6 FAIL: function-log is NOT recognized as a function")))
  </script>

  <script type="application/x-scittle">
    ;; Test 7: Trove macros - are they really macros?
    (println "\n=== Test 7: Trove Macros Check ===")
    
    ;; Load Trove
    (require '[taoensso.trove :as trove])
    
    (let [log-meta (meta #'trove/log!)]
      (println (str "trove/log! metadata: " log-meta))
      (if (:macro log-meta)
        (println "‚úÖ Test 7 PASS: trove/log! is a macro")
        (println "‚ùå Test 7 FAIL: trove/log! is NOT a macro")))
  </script>

  <script type="application/x-scittle">
    ;; Test 8: Our wrapper - is it a macro or function?
    (println "\n=== Test 8: Our Wrapper Check ===")
    
    ;; Load our wrapper
    (require '[trove.macros :refer [log!]])
    
    (let [wrapper-meta (meta #'trove.macros/log!)]
      (println (str "trove.macros/log! metadata: " wrapper-meta))
      (if (:macro wrapper-meta)
        (println "‚úÖ Test 8 PASS: Our wrapper is a macro")
        (println "‚ùå Test 8 FAIL: Our wrapper is a FUNCTION (not optimized!)")))
  </script>

  <script type="application/x-scittle">
    ;; Final Summary
    (println "\n=== SUMMARY ===")
    (println "‚úÖ All tests completed!")
    (println "\nKey Finding:")
    (println "When using :refer with macros in Scittle:")
    (println "- Macros ARE expanded at compile time")
    (println "- Functions are NOT expanded")
    (println "- Our wrapper is a FUNCTION, not a macro")
    (println "- So we get function behavior (parameters always evaluated)")
  </script>
</body>
</html>
